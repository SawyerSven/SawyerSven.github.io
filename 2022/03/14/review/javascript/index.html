<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="2022春季复习之Javascript"><meta name="keywords" content="复习,javascript,手写代码"><meta name="author" content="Siyuan"><meta name="copyright" content="Siyuan"><title>2022春季复习之Javascript | Neverland</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">手写常用工具函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96-debounce-%E5%92%8C%E8%8A%82%E6%B5%81-throttle"><span class="toc-number">1.1.</span> <span class="toc-text">防抖(debounce)和节流(throttle)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0-debounce"><span class="toc-number">1.1.1.</span> <span class="toc-text">防抖函数(debounce)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0-throttle"><span class="toc-number">1.1.2.</span> <span class="toc-text">节流函数(throttle)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">时间戳实现:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">定时器实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rAF%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">rAF实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.2.</span> <span class="toc-text">深浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B-amp-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本类型 &amp; 引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">深浅拷贝定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">深拷贝的几种实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSON%E5%A4%A7%E6%B3%95"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">JSON大法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%89%88"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">基础版</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">处理数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">循环引用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WeakMap%E5%92%8CMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.3.4.1.</span> <span class="toc-text">WeakMap和Map的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">其他数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%8C%81%E7%BB%AD%E9%81%8D%E5%8E%86%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">可持续遍历的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E7%BB%A7%E7%BB%AD%E9%81%8D%E5%8E%86%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.8.</span> <span class="toc-text">不可继续遍历类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8B%E9%9A%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.9.</span> <span class="toc-text">克隆函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.2.4.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="http://47.95.214.156:3001/uploads/medium/1081ccc0f270fb058ae48545b1b6f4eb.jpg"></div><div class="author-info__name text-center">Siyuan</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/sawyersven">Follo Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">10</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">10</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">4</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://47.95.214.156:3001/uploads/medium/fcec6883177323ae1bf9a3dae581059f.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Neverland</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">2022春季复习之Javascript</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-03-14</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/javascript/">javascript</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2022/03/14/review/javascript/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2022/03/14/review/javascript/"></span></a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">2.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 10 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h1 id="手写常用工具函数"><a href="#手写常用工具函数" class="headerlink" title="手写常用工具函数"></a>手写常用工具函数</h1><h2 id="防抖-debounce-和节流-throttle"><a href="#防抖-debounce-和节流-throttle" class="headerlink" title="防抖(debounce)和节流(throttle)"></a>防抖(debounce)和节流(throttle)</h2><p><strong>目的</strong>：为了解决DOM事件如onresize,mousemove或input的change等事件频繁触发导致的事件在短时间内频繁调用增加的浏览器负担及性能影响。</p>
<p><strong>区别</strong>：</p>
<ul>
<li>防抖： 单位时间内多次触发事件，最后一次执行事件处理函数</li>
<li>节流： 固定间隔执行时间处理函数</li>
</ul>
<h3 id="防抖函数-debounce"><a href="#防抖函数-debounce" class="headerlink" title="防抖函数(debounce)"></a>防抖函数(debounce)</h3><p><strong>思路</strong>: 第一次触发事件的时候，设置定时器。如果在定时器结束前重复触发事件，则重置定时器。如果定时器结束前没有新的事件触发，则定时器结束后执行事件处理函数</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn, delay</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, ...args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="节流函数-throttle"><a href="#节流函数-throttle" class="headerlink" title="节流函数(throttle)"></a>节流函数(throttle)</h3><p><strong>时间戳实现思路</strong>: 事件触发时候，判断上次执行的时间戳lastInvoke，如果存在则判断上次执行距现在是否大于指定的delay，是则再次执行事件处理函数，并且将当前时间戳设定为lastInvoke。<br>反之则不作操作。如果lastInvoke不存在，则设定当前时间戳为lastInvoke,并且执行时间处理函数</p>
<h4 id="时间戳实现"><a href="#时间戳实现" class="headerlink" title="时间戳实现:"></a>时间戳实现:</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, delay</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> lastInvoke = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> time = <span class="title class_">Date</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">if</span> (lastInvoke + delay &lt; time) &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, args)</span><br><span class="line">      lastInvoke = time</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> throttled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点: 最后一次触发回调与前一次的触发回调时间差小于delay,则最后一次触发事件不会执行</p>
<h4 id="定时器实现"><a href="#定时器实现" class="headerlink" title="定时器实现"></a>定时器实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, delay</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">throttled</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span></span><br><span class="line">    flag = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>,args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> throttled</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点： 第一次触发的事件不会立即执行，也会等待delay时间后才会执行</p>
<h3 id="rAF实现"><a href="#rAF实现" class="headerlink" title="rAF实现"></a>rAF实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">throttle</span> = (<span class="params">fn, delay</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> flag</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      <span class="keyword">let</span> that = <span class="variable language_">this</span></span><br><span class="line">      <span class="title function_">requestAnimationFrame</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        fn.<span class="title function_">apply</span>(that, args)</span><br><span class="line">        flag = <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    flag = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h3 id="基本类型-amp-引用类型"><a href="#基本类型-amp-引用类型" class="headerlink" title="基本类型 &amp; 引用类型"></a>基本类型 &amp; 引用类型</h3><p><strong>区别</strong>:</p>
<ul>
<li><em>基本类型</em>在内存中占据固定大小，保存在内存栈当中</li>
<li><em>引用类型</em>的值是对象，保存在堆内存，而栈内存存储的是<em>对象的标识符</em>以及<em>对象在堆内存中的十六进制存储地址</em></li>
</ul>
<p><strong>复制方式</strong>:</p>
<ul>
<li><em>基本类型</em>：从一个变量向另一个新变量复制基本类型的值，会创建一个这个值的副本，并将该副本复制给新变量</li>
<li><em>引用类型的</em>：从一个变量向另一个新变量复制引用类型的的值，其实复制的是指针，最终两个变量都指向同一个对象</li>
</ul>
<h3 id="深浅拷贝定义"><a href="#深浅拷贝定义" class="headerlink" title="深浅拷贝定义"></a>深浅拷贝定义</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/1/16ce894a1f1b5c32~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="浅拷贝"></p>
<blockquote>
<p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型的，拷贝的就是内存地址，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
</blockquote>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/9/1/16ce893a54f6c13d~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="深拷贝"></p>
<blockquote>
<p>将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原始对象。</p>
</blockquote>
<h3 id="深拷贝的几种实现方式"><a href="#深拷贝的几种实现方式" class="headerlink" title="深拷贝的几种实现方式"></a>深拷贝的几种实现方式</h3><h4 id="JSON大法"><a href="#JSON大法" class="headerlink" title="JSON大法"></a>JSON大法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>优点: 写法简单，适用于大部分应用场景<br>缺点：部分场景不适用，如循环引用、拷贝其他引用类型、面试只写这一种卷王肯定不会让你过</p>
<h4 id="基础版"><a href="#基础版" class="headerlink" title="基础版"></a>基础版</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">clone</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      cloneTarget[key] = <span class="title function_">clone</span>(target[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>做深拷贝时，我们不知道要拷贝的对象有多少层深度，所以用递归来解决问题</p>
<p>整体逻辑：</p>
<ul>
<li>如果target是原始类型,无需继续拷贝,直接返回</li>
<li>如果是引用类型，创建一个新的对象，遍历需要克隆的对象，将要克隆的对象的属性递归执行clone后依次添加到新对象上</li>
</ul>
<h4 id="处理数组"><a href="#处理数组" class="headerlink" title="处理数组"></a>处理数组</h4><p>上边的代码并没有考虑到数组应该如何处理，只处理了普通的Object，所以需要对数组做兼容处理:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">clone</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 这一行判断target是否是数组并进行不同的初始化</span></span><br><span class="line">    <span class="keyword">let</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      cloneTarget[key] = <span class="title function_">clone</span>(target[key])</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>上边的代码如果遇倒循环引用则会导致栈内存溢出</p>
<p>如: </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">target.<span class="property">target</span> = target</span><br></pre></td></tr></table></figure>

<blockquote>
<p>会返回<em>Maximum call stack size exceeded</em></p>
</blockquote>
<p>因为递归进入死循环导致栈内存溢出。</p>
<p>原因就是上面的对象存在循环引用的情况，即对象的属性间接或直接引用了自身的情况</p>
<p>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间找，有没有拷贝过这个对象，<br>如果有的话直接返回，没有的话继续拷贝，这样就巧妙化解循环引用的问题</p>
<p>这个存储空间需要可以存储<code>key-value</code> 形式的数据，而且key可以是一个引用类型，我们可以选择<code>Map</code>数据结构:</p>
<ul>
<li>检查<code>map</code>中有无克隆过的对象<ul>
<li>有 - 直接返回</li>
<li>没有 - 将当前对象作为<code>key</code>,克隆对象作为<code>value</code>进行存储</li>
</ul>
</li>
<li>继续克隆</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">clone</span> = (<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">get</span>(target)) &#123;</span><br><span class="line">      <span class="keyword">return</span> map.<span class="title function_">get</span>(target)</span><br><span class="line">    &#125;</span><br><span class="line">    map.<span class="title function_">set</span>(target, cloneTarget)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">      cloneTarget[key] = <span class="title function_">clone</span>(target[key], map)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">field1</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">field2</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">field3</span>: <span class="string">&#x27;ConardLi&#x27;</span>,</span><br><span class="line">  <span class="attr">field4</span>: &#123;</span><br><span class="line">    <span class="attr">child</span>: <span class="string">&#x27;child&#x27;</span>,</span><br><span class="line">    <span class="attr">child2</span>: &#123;</span><br><span class="line">      <span class="attr">child2</span>: <span class="string">&#x27;child2&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">field5</span>: [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="attr">field6</span>: [&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Siyuan&#x27;</span></span><br><span class="line">  &#125;,&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;Mingyang&#x27;</span></span><br><span class="line">  &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data.<span class="property">reference</span> = data</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用上边的用例和代码执行clone操作，打印出clone后的结果</p>
<p><img src="http://47.95.214.156:3001/uploads/big/9062fbaad26f319e98bf9dd11c72b0a5.png"></p>
<p>其中reference的值是一个Circular,指代循环引用</p>
<p>使用WeakMap代替Map起到画龙点睛的作用，即：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">target,map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="WeakMap和Map的区别"><a href="#WeakMap和Map的区别" class="headerlink" title="WeakMap和Map的区别"></a>WeakMap和Map的区别</h5><p>先看MDN的描述:</p>
<blockquote>
<p>Map对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或原始值)都可以作为一个键或一个值</p>
</blockquote>
<blockquote>
<p>WeakMap对象是一组键值对的集合，其中的键是<code>弱引用</code>的。其键<code>必须是对象</code>,而值可以是任意的</p>
</blockquote>
<p>弱引用：</p>
<blockquote>
<p>在计算机程序设计中,弱引用与强引用相对，是指不能确保其引用对象不会被垃圾回收器回收的引用。一个对象若只被弱引用所引用，则认为是不可访问(或弱可访问)的，<br>并因此可能在任何时候被回收。</p>
</blockquote>
<p>我们默认创建一个对象:<code>const obj = &#123;&#125;</code>就默认创建了一个强引用对象，我们只有手动将<code>obj = null</code>,才会被垃圾回收机制进行回收，如果是弱引用对象，<br>垃圾回收机制会自动帮我们回收。</p>
<p>使用<code>Map</code>时，对象间存在强引用关系，即使手动释放obj,target依然对<code>obj</code>存在强引用关系,所以这部分内存依然无法被释放。</p>
<p>如果使用<code>WeakMap</code>，<code>target</code>和<code>obj</code>存在的就是弱引用关系,当下一次垃圾回收机制执行时,这块内存就会被释放掉。</p>
<p>如果我们要拷贝的对象非常庞大时，使用<code>Map</code>会对内存造成非常大的额外消耗，而我们需要手动清除<code>Map</code>的属性才能释放这块内存，而<br><code>WeakMap</code>会帮我们巧妙化解这个问题。</p>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>使用while代替for..in以获得更好的性能表现。 详情见参考3</p>
<h4 id="其他数据类型"><a href="#其他数据类型" class="headerlink" title="其他数据类型"></a>其他数据类型</h4><p>在目前的实现中，只考虑了普通<code>object</code>和<code>array</code>两种数据类型,实际上所有的引用类型还有很多。</p>
<p>可以使用<code>toString</code>来获取准确的引用类型的:</p>
<blockquote>
<p>每一个引用类型都有toString方法，默认情况下,<code>toString</code>被每个<code>Object</code>对象继承。如果此方法在自定义对象中未被覆盖，<code>toString</code>返回<br><code>&quot;[object type]&quot;</code>，其中type是对象的类型。</p>
</blockquote>
<p>大部分引用类型比如<code>Array、Date、RegExp</code>等都重写了<code>toString</code>方法</p>
<p>可以直接调用<code>Object</code>原型上未被覆盖的<code>toString()</code>方法，使用<code>call</code>来改变<code>this</code>指向来达到我们想要的效果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(target)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>抽离一些常用的数据类型以便后续使用:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapTag = <span class="string">&#x27;[object Map]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> setTag = <span class="string">&#x27;[object Set]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> arrayTag = <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> objectTag = <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> boolTag = <span class="string">&#x27;[object Boolean]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> dateTag = <span class="string">&#x27;[object Date]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> errorTag = <span class="string">&#x27;[object Error]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> numberTag = <span class="string">&#x27;[object Number]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> regexpTag = <span class="string">&#x27;[object RegExp]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> stringTag = <span class="string">&#x27;[object String]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> symbolTag = <span class="string">&#x27;[object Symbol]&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的类型中，简单分为两类：</p>
<ul>
<li>可以继续遍历的类型</li>
<li>不可以继续遍历的类型</li>
</ul>
<p>分别为他们做不同的拷贝。</p>
<h4 id="可持续遍历的类型"><a href="#可持续遍历的类型" class="headerlink" title="可持续遍历的类型"></a>可持续遍历的类型</h4><p>上文的<code>object、array</code>都属于可以继续遍历的类型，因为它们内存都还可以存储其他数据类型的数据，另外还有<code>Map,Set</code>等都是可以继续遍历的类型。这里只考虑这四种。</p>
<p>这几种类型还需要继续进行递归，首先要获取他们的初始化数据，例如<code>[]</code>和<code>&#123;&#125;</code>,我们可以通过拿到<code>constructor</code>的方式来通用的获取</p>
<p>例如:<code>const target = &#123;&#125;</code>就是<code>const target = new Object()</code>的语法糖。并且这种方法因为使用了原对象的构造方法，所以它可以保留对象原型上的数据。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInit</span>(<span class="params">target</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Ctor</span> = target.<span class="property">constructor</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ctor</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改写<code>clone</code>函数:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">forEach</span>(<span class="params">array, iteratee</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> length = array.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (++index &lt; length) &#123;</span><br><span class="line">    <span class="title function_">iteratee</span>(array[index], index)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getType</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(target)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isObject</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> type = <span class="keyword">typeof</span> target</span><br><span class="line">  <span class="keyword">return</span> target !== <span class="literal">null</span> &amp;&amp; (type === <span class="string">&#x27;object&#x27;</span> || type === <span class="string">&#x27;function&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getInit</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Ctor</span> = target.<span class="property">constructor</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ctor</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">clone</span> = (<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> type = <span class="title function_">getType</span>(target)</span><br><span class="line">  <span class="keyword">let</span> cloneTarget</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (deepTag.<span class="title function_">includes</span>(type)) &#123;</span><br><span class="line">    cloneTarget = <span class="title function_">getInit</span>(target, type)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 防止循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (map.<span class="title function_">get</span>(target)) &#123;</span><br><span class="line">    <span class="keyword">return</span> map.<span class="title function_">get</span>(target)</span><br><span class="line">  &#125;</span><br><span class="line">  map.<span class="title function_">set</span>(target, cloneTarget)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//克隆set</span></span><br><span class="line">  <span class="keyword">if</span> (type === deepTagMap.<span class="property">setTag</span>) &#123;</span><br><span class="line">    target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.<span class="title function_">add</span>(<span class="title function_">clone</span>(value, map))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 克隆map</span></span><br><span class="line">  <span class="keyword">if</span> (type === deepTagMap.<span class="property">mapTag</span>) &#123;</span><br><span class="line">    target.<span class="title function_">forEach</span>(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">      cloneTarget.<span class="title function_">set</span>(key, <span class="title function_">clone</span>(value, map))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 克隆对象和数组</span></span><br><span class="line">  <span class="keyword">const</span> keys = type === deepTagMap.<span class="property">arrayTag</span> ? <span class="literal">undefined</span> : <span class="title class_">Object</span>.<span class="title function_">keys</span>(target)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">forEach</span>(keys || target, <span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (keys) &#123;</span><br><span class="line">      key = value</span><br><span class="line">    &#125;</span><br><span class="line">    cloneTarget[key] = <span class="title function_">clone</span>(target[key], map)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="不可继续遍历类型"><a href="#不可继续遍历类型" class="headerlink" title="不可继续遍历类型"></a>不可继续遍历类型</h4><p>其他剩余类型统一归类成不可处理的数据类型，依次进行处理：</p>
<p><code>Bool</code>,<code>Number</code>,<code>String</code>,<code>Date</code>,<code>Error</code>这几种类型都可以直接用构造函数和原始数据创建一个新对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">cloneOtherType</span>(<span class="params">target, type</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">Ctor</span> = target.<span class="property">constructor</span>;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">boolTag</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">numberTag</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">stringTag</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">errorTag</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">dateTag</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Ctor</span>(target);</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">regexpTag</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">cloneReg</span>(target);</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">symbolTag</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">cloneSymbol</span>(target);</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>克隆<code>symbol</code>类型:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cloneSymbol</span>(<span class="params">target</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>(<span class="title class_">Symbol</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">valueOf</span>.<span class="title function_">call</span>(target))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>克隆<code>正则</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cloneReg</span>(<span class="params">target</span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> target.<span class="title function_">constructor</span>(<span class="params">target.source,reFlags.exec(target)</span>);</span><br><span class="line">  result.<span class="property">lastIndex</span> = target.<span class="property">lastIndex</span>;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上还有很多数据类型没有写到.可以继续探索实现。</p>
<h4 id="克隆函数"><a href="#克隆函数" class="headerlink" title="克隆函数"></a>克隆函数</h4><p>这里不考虑克隆函数的实现。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>1 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakMap">WeakMap - MDN</a></li>
<li>2 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">Map - MDN</a></li>
<li>3 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903929705136141#comment">如何写出一个惊艳面试官的深拷贝?</a></li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Siyuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/03/14/review/javascript/">http://example.com/2022/03/14/review/javascript/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a> 许可协议。转载请注明来自 <a href="http://example.com">Neverland</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%8D%E4%B9%A0/">复习</a><a class="post-meta__tags" href="/tags/javascript/">javascript</a><a class="post-meta__tags" href="/tags/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/">手写代码</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/07/01/git/git/"><i class="fa fa-chevron-left">  </i><span>Git实用命令</span></a></div><div class="next-post pull-right"><a href="/2022/02/11/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/element-init-source/"><span>Element-UI初始化组件源码</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://example.com/2022/03/14/review/javascript/';
  this.page.identifier = '2022/03/14/review/javascript/';
  this.page.title = '2022春季复习之Javascript';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'blog-gb2jzpokgw' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://blog-gb2jzpokgw.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(http://47.95.214.156:3001/uploads/medium/fcec6883177323ae1bf9a3dae581059f.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2022 By Siyuan</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">但行好事，莫问前程</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>